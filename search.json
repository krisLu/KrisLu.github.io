[{"path":"/2023/09/19/sql优化/","content":"1.select * ​\t首先当查询sql时，*会增加sql查询解析的负担，当表字段量非常大，则每次查 *都会被重新解析字段对sql服务造成很大负担 ​\t第二就会覆盖索引，在条件查询时，通过索引进行查询，只查询一次b+树，而当查询*时候，则会先查非聚簇索引的b+树在查聚簇b+树 2.小数据集驱动大数据集（使用in而不是exists） ​\t使用select id from goods where name exists (select name …)如果goods表是一张非常大的表，则他会先查大表然后进行过滤，而in则会先查后边的表在查前边的表 3.尽量不要一条sql操作两张表。避免使用多表查询 12345select *from goods as gwhere g.restaurant_id in (select idfrom lrestaurantswhere wechat_id =1) 建议：例如查询id，可以在程序中将id查询出放入列表。作为参数。 4.使用批量插入代替循环插入 使用mybatis的insertBatch（list） 5.使用limit限制返回条数，避免内存溢出，查询接口尽量使用limit 6.es索引构建的定时任务 123select id, name from restaurantswhere updated_at &gt; (now()-2min) ; 7.分页查询优化 1234567select id, name,pricefrom goodslimit 1,30;王#随着pageNo不断增大,查询效率变低#int lastMaxId = 100;(前端传递)select id, name, pricefrom goodswhere id &gt; 100limit 1,30; 8.缩小过滤集的条件放到前边 123456select id, namefrom restaurantswhere is_deletedand wechat_id and discount &gt; 20# 先使用wechatId缩小范围在条件过滤"},{"title":"Hello World","path":"/2023/09/19/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"这是分页标题","path":"/stellar/index.html","content":"你是暗杀掉后阿松大阿萨大赛 撒旦撒旦"},{"title":"这是分页标题","path":"/wiki/stellar/index.html","content":"ASDA"},{"path":"/notes/ape-frame.html","content":"集成Mybatis-plus模块po，dto区别po只和数据层进行交互，dto可以实现多个po聚合，进行数据体的转换 元数据处理在插入数据的时候会有一些create_by，create_time等一些数据，手动进行填充会使代码冗余，且没有实际意义，所以需要简化自己的处理方式。 当处理相同逻辑的数据库字段的插入和更新时候，可以继承MetaObjectHandler类，实现insert，update两个方法， 1234567891011121314151617@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; this.strictInsertFill(metaObject, &quot;createBy&quot;, String.class, &quot;jingdianjichi&quot;); this.strictInsertFill(metaObject, &quot;createTime&quot;, Date.class, new Date()); this.strictInsertFill(metaObject, &quot;deleteFlag&quot;, Integer.class, 0); this.strictInsertFill(metaObject, &quot;version&quot;, Integer.class, 0); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.strictUpdateFill(metaObject, &quot;updateBy&quot;, String.class, &quot;jingdianjichi&quot;); this.strictUpdateFill(metaObject, &quot;updateTime&quot;, Date.class, new Date()); &#125;&#125; 附加：version字段为后续的乐观锁做准备 集成druid监控12345678910111213141516171819spring:\tdatasource: druid: initial-size: 20 min-idle: 20 max-active: 100 max-wait: 60000 stat-view-servlet: enabled: true url-pattern: /druid/* login-username: admin login-password: 123456 filter: stat: enabled: true log-slow-sql: true slow-sql-millis: 2000 #设置超过2秒为慢查询 wall: enabled: true #启动sql防火墙 可以通过8081&#x2F;druid&#x2F;login.html进行登录监控系统查看sql执行情况 image-20230908111812630 集成mp插件集成公用拦截器插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195package com.jingdianjichi.inteceptor;import org.apache.ibatis.executor.statement.StatementHandler;import org.apache.ibatis.mapping.BoundSql;import org.apache.ibatis.mapping.ParameterMapping;import org.apache.ibatis.plugin.*;import org.apache.ibatis.session.ResultHandler;import org.apache.ibatis.session.defaults.DefaultSqlSession.StrictMap;import java.lang.reflect.Field;import java.sql.Statement;import java.util.*;@Intercepts(value = &#123; @Signature(args = &#123;Statement.class, ResultHandler.class&#125;, method = &quot;query&quot;, type = StatementHandler.class), @Signature(args = &#123;Statement.class&#125;, method = &quot;update&quot;, type = StatementHandler.class), @Signature(args = &#123;Statement.class&#125;, method = &quot;batch&quot;, type = StatementHandler.class)&#125;)public class SqlBeautyInterceptor implements Interceptor &#123; @Override public Object intercept(Invocation invocation) throws Throwable &#123; Object target = invocation.getTarget(); long startTime = System.currentTimeMillis(); StatementHandler statementHandler = (StatementHandler) target; try &#123; return invocation.proceed(); &#125; finally &#123; long endTime = System.currentTimeMillis(); long sqlCost = endTime - startTime; BoundSql boundSql = statementHandler.getBoundSql(); String sql = boundSql.getSql(); Object parameterObject = boundSql.getParameterObject(); List&lt;ParameterMapping&gt; parameterMappingList = boundSql.getParameterMappings(); sql = formatSql(sql, parameterObject, parameterMappingList); System.out.println(&quot;SQL： [ &quot; + sql + &quot; ]执行耗时[ &quot; + sqlCost + &quot;ms ]&quot;); &#125; &#125; @Override public Object plugin(Object o) &#123; return Plugin.wrap(o, this); &#125; @Override public void setProperties(Properties properties) &#123; &#125; private String formatSql(String sql, Object parameterObject, List&lt;ParameterMapping&gt; parameterMappingList) &#123; if (sql == &quot;&quot; || sql.length() == 0) &#123; return &quot;&quot;; &#125; sql = beautifySql(sql); if (parameterObject == null || parameterMappingList == null || parameterMappingList.size() == 0) &#123; return sql; &#125; String sqlWithoutReplacePlaceholder = sql; try &#123; if (parameterMappingList != null) &#123; Class&lt;?&gt; parameterObjectClass = parameterObject.getClass(); if (isStrictMap(parameterObjectClass)) &#123; StrictMap&lt;Collection&lt;?&gt;&gt; strictMap = (StrictMap&lt;Collection&lt;?&gt;&gt;) parameterObject; if (isList(strictMap.get(&quot;list&quot;).getClass())) &#123; sql = handleListParameter(sql, strictMap.get(&quot;list&quot;)); &#125; &#125; else if (isMap(parameterObjectClass)) &#123; Map&lt;?, ?&gt; paramMap = (Map&lt;?, ?&gt;) parameterObject; sql = handleMapParameter(sql, paramMap, parameterMappingList); &#125; else &#123; sql = handleCommonParameter(sql, parameterMappingList, parameterObjectClass, parameterObject); &#125; &#125; &#125; catch (Exception e) &#123; return sqlWithoutReplacePlaceholder; &#125; return sql; &#125; private String handleCommonParameter(String sql, List&lt;ParameterMapping&gt; parameterMappingList, Class&lt;?&gt; parameterObjectClass, Object parameterObject) throws Exception &#123; Class&lt;?&gt; originalParameterObjectClass = parameterObjectClass; List&lt;Field&gt; allFieldList = new ArrayList&lt;&gt;(); while (parameterObjectClass != null) &#123; allFieldList.addAll(new ArrayList&lt;&gt;(Arrays.asList(parameterObjectClass.getDeclaredFields()))); parameterObjectClass = parameterObjectClass.getSuperclass(); &#125; Field[] fields = new Field[allFieldList.size()]; fields = allFieldList.toArray(fields); parameterObjectClass = originalParameterObjectClass; for (ParameterMapping parameterMapping : parameterMappingList) &#123; String propertyValue = null; if (isPrimitiveOrPrimitiveWrapper(parameterObjectClass)) &#123; propertyValue = parameterObject.toString(); &#125; else &#123; String propertyName = parameterMapping.getProperty(); Field field = null; for (Field everyField : fields) &#123; if (everyField.getName().equals(propertyName)) &#123; field = everyField; &#125; &#125; field.setAccessible(true); propertyValue = String.valueOf(field.get(parameterObject)); if (parameterMapping.getJavaType().isAssignableFrom(String.class)) &#123; propertyValue = &quot;\\&quot;&quot; + propertyValue + &quot;\\&quot;&quot;; &#125; &#125; sql = sql.replaceFirst(&quot;\\\\?&quot;, propertyValue); &#125; return sql; &#125; private String handleMapParameter(String sql, Map&lt;?, ?&gt; paramMap, List&lt;ParameterMapping&gt; parameterMappingList) &#123; for (ParameterMapping parameterMapping : parameterMappingList) &#123; Object propertyName = parameterMapping.getProperty(); Object propertyValue = paramMap.get(propertyName); if (propertyValue != null) &#123; if (propertyValue.getClass().isAssignableFrom(String.class)) &#123; propertyValue = &quot;\\&quot;&quot; + propertyValue + &quot;\\&quot;&quot;; &#125; sql = sql.replaceFirst(&quot;\\\\?&quot;, propertyValue.toString()); &#125; &#125; return sql; &#125; private String handleListParameter(String sql, Collection&lt;?&gt; col) &#123; if (col != null &amp;&amp; col.size() != 0) &#123; for (Object obj : col) &#123; String value = null; Class&lt;?&gt; objClass = obj.getClass(); if (isPrimitiveOrPrimitiveWrapper(objClass)) &#123; value = obj.toString(); &#125; else if (objClass.isAssignableFrom(String.class)) &#123; value = &quot;\\&quot;&quot; + obj.toString() + &quot;\\&quot;&quot;; &#125; sql = sql.replaceFirst(&quot;\\\\?&quot;, value); &#125; &#125; return sql; &#125; private String beautifySql(String sql) &#123; sql = sql.replaceAll(&quot;[\\\\s ]+&quot;, &quot; &quot;); return sql; &#125; private boolean isPrimitiveOrPrimitiveWrapper(Class&lt;?&gt; parameterObjectClass) &#123; return parameterObjectClass.isPrimitive() || (parameterObjectClass.isAssignableFrom(Byte.class) || parameterObjectClass.isAssignableFrom(Short.class) || parameterObjectClass.isAssignableFrom(Integer.class) || parameterObjectClass.isAssignableFrom(Long.class) || parameterObjectClass.isAssignableFrom(Double.class) || parameterObjectClass.isAssignableFrom(Float.class) || parameterObjectClass.isAssignableFrom(Character.class) || parameterObjectClass.isAssignableFrom(Boolean.class)); &#125; /** * 是否DefaultSqlSession的内部类StrictMap */ private boolean isStrictMap(Class&lt;?&gt; parameterObjectClass) &#123; return parameterObjectClass.isAssignableFrom(StrictMap.class); &#125; /** * 是否List的实现类 */ private boolean isList(Class&lt;?&gt; clazz) &#123; Class&lt;?&gt;[] interfaceClasses = clazz.getInterfaces(); for (Class&lt;?&gt; interfaceClass : interfaceClasses) &#123; if (interfaceClass.isAssignableFrom(List.class)) &#123; return true; &#125; &#125; return false; &#125; /** * 是否Map的实现类 */ private boolean isMap(Class&lt;?&gt; parameterObjectClass) &#123; Class&lt;?&gt;[] interfaceClasses = parameterObjectClass.getInterfaces(); for (Class&lt;?&gt; interfaceClass : interfaceClasses) &#123; if (interfaceClass.isAssignableFrom(Map.class)) &#123; return true; &#125; &#125; return false; &#125;&#125; 在配置类中将拦截器插件导入进来 12345@Bean public SqlBeautyInterceptor sqlBeautyInterceptor() &#123; return new SqlBeautyInterceptor(); &#125; 优化使用Conditional注解 在一定情况下，对于一些业务方可能不需要一些插件，可以使用@Conditional系列注解进行指定特定情况下开启 12345@Bean @ConditionalOnProperty(name = &#123;&quot;sql.beauty.show&quot;&#125;, havingValue = &quot;true&quot;, matchIfMissing = true) public SqlBeautyInterceptor sqlBeautyInterceptor() &#123; return new SqlBeautyInterceptor(); &#125; 共有实体抽取需要实现序列化接口 123456789101112131415161718192021222324252627282930313233package com.jingdianjichi.entity;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableLogic;import lombok.Data;import java.io.Serializable;import java.util.Date;@Datapublic class BaseEntity implements Serializable &#123; @TableField(fill = FieldFill.INSERT) private String createBy; @TableField(fill = FieldFill.INSERT) private Date createTime; @TableField(fill = FieldFill.UPDATE) private String updateBy; @TableField(fill = FieldFill.UPDATE) private Date updateTime; @TableField(fill = FieldFill.INSERT) @TableLogic private Integer deleteFlag; @TableField(fill = FieldFill.INSERT) private Integer version;&#125; pageresult1234567891011121314151617181920212223@Datapublic class PageResult&lt;T&gt; implements Serializable &#123; private Long total; private Long size; private Long current; private Long pages; private List&lt;T&gt; records = Collections.emptyList(); public void loadData(IPage&lt;T&gt; pageData)&#123; this.setCurrent(pageData.getCurrent()); this.setPages(pageData.getPages()); this.setSize(pageData.getSize()); this.setTotal(pageData.getTotal()); this.setRecords(pageData.getRecords()); &#125;&#125; Param注解image-20230908170548501 当我们打上了@Param注解，需要对应在mappering文件中加上前缀 image-20230908192141258 抽取公共page类分页pageRequest抽取分页算法所需要的两个参数为公共类 123456789101112131415161718192021222324@Setterpublic class PageRequest &#123; private Long pageNo = 1L; private Long pageSize = 10L; //进行参数判断 public Long getPageNo()&#123; if(pageNo == null || pageNo &lt; 1)&#123; return 1L; &#125; return pageNo; &#125; public Long getPageSize()&#123; if(pageSize == null || pageSize &lt; 1 || pageSize &gt; Integer.MAX_VALUE)&#123; return 10L; &#125; return pageSize; &#125;&#125; 集成mapstructbeansUtils.copyProperties效率比较低 ，所以我们引入mapStruct 创建convert，定义一个接口 1234567891011//Mapper属于org.mapstruct@Mapperpublic interface SysUserConverter &#123; SysUserConverter INSTANCE = Mappers.getMapper(SysUserConverter.class); //如果属性名不一样的情况可以使用Mapping注解来进行字段映射 @Mapping(source=&quot;age&quot;, target=&quot;age1&quot;) SysUser convertReqToSysUser(SysUserReq sysUserReq);&#125;//使用,将req对象映射到user对象 SysUser sysUser = SysUserConverter。INSTANCE.convertReqToSysUser(sysUserReq); 集成Web模块全局异常处理异常处理注解@RestControllerAdvice主要用精简客户端返回异常，它可以捕获各种异常 处理步骤 配置异常拦截器 12345678910111213141516@RestControllerAdvicepublic class ExceptionAdaptController &#123; @ExceptionHandler(&#123;RuntimeException.class&#125;) public Result runTimeException(RuntimeException exception)&#123; exception.printStackTrace(); return Result.fail(); &#125; @ExceptionHandler(&#123;Exception.class&#125;) public Result exception(Exception exception)&#123; exception.printStackTrace(); return Result.fail(); &#125;&#125; 处理前后对比处理前 1int i = 1/0; 对于前端来说，返回的信息，无法识别 image-20230908114333462 处理后 image-20230908115045001 集成WebSocket导入spring-boot-starter-websocket 添加webSocket配置类 123456789@Configurationpublic class WebSocketConfig &#123; @Bean public ServerEndpointExporter serverEndpointExporter() &#123; return new ServerEndpointExporter(); &#125;&#125; 1234567891011121314151617181920@Componentpublic class WebSocketServerConfig extends ServerEndpointConfig.Configurator &#123; @Override public boolean checkOrigin(String originHeaderValue) &#123; ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = servletRequestAttributes.getRequest(); return true; &#125; @Override public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response) &#123; Map&lt;String, List&lt;String&gt;&gt; parameterMap = request.getParameterMap(); List&lt;String&gt; erpList = parameterMap.getOrDefault(&quot;erp&quot;, null); if (!CollectionUtils.isEmpty(erpList)) &#123; sec.getUserProperties().put(&quot;erp&quot;, erpList.get(0)); &#125; &#125;&#125; WebSocket要保证操作的原子性，所以使用AutomicInt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121@Slf4j@ServerEndpoint(value = &quot;/chicken/socket&quot;, configurator = WebSocketServerConfig.class)@Componentpublic class ChickenSocket &#123; /** * 记录当前在线连接数 */ private static AtomicInteger onlineCount = new AtomicInteger(0); /** * 存放所有在线的客户端 */ private static Map&lt;String, ChickenSocket&gt; clients = new ConcurrentHashMap&lt;&gt;(); /** * 与某个客户端的连接会话，需要通过它来给客户端发送数据 */ private Session session; /** * erp唯一标识 */ private String erp = &quot;&quot;; /** * 连接建立成功调用的方法 */ @OnOpen public void onOpen(Session session, EndpointConfig conf) throws IOException &#123; //获取用户信息 try &#123; Map&lt;String, Object&gt; userProperties = conf.getUserProperties(); String erp = (String) userProperties.get(&quot;erp&quot;); this.erp = erp; this.session = session; //如果电脑端已连接，现在在手机端再次连接，需要进行判断，如果存在，则将电脑端移除。 if (clients.containsKey(this.erp)) &#123; clients.get(this.erp).session.close(); clients.remove(this.erp); onlineCount.decrementAndGet(); &#125; //移除后将手机端的erp放入 clients.put(this.erp, this); onlineCount.incrementAndGet(); log.info(&quot;有新连接加入：&#123;&#125;，当前在线人数为：&#123;&#125;&quot;, erp, onlineCount.get()); sendMessage(&quot;连接成功&quot;, this.session); &#125; catch (Exception e) &#123; log.error(&quot;建立链接错误&#123;&#125;&quot;, e.getMessage(), e); &#125; &#125; /** * 连接关闭调用的方法 */ @OnClose public void onClose() &#123; try &#123; if (clients.containsKey(erp)) &#123; clients.get(erp).session.close(); clients.remove(erp); onlineCount.decrementAndGet(); &#125; log.info(&quot;有一连接关闭：&#123;&#125;，当前在线人数为：&#123;&#125;&quot;, this.erp, onlineCount.get()); &#125; catch (Exception e) &#123; log.error(&quot;连接关闭错误，错误原因&#123;&#125;&quot;, e.getMessage(), e); &#125; &#125; /** * 收到客户端消息后调用的方法 */ @OnMessage public void onMessage(String message, Session session) &#123; log.info(&quot;服务端收到客户端[&#123;&#125;]的消息:&#123;&#125;&quot;, this.erp, message); //心跳机制 if (message.equals(&quot;ping&quot;)) &#123; this.sendMessage(&quot;pong&quot;, session); &#125; &#125; @OnError public void onError(Session session, Throwable error) &#123; log.error(&quot;Socket:&#123;&#125;,发生错误,错误原因&#123;&#125;&quot;, erp, error.getMessage(), error); try &#123; session.close(); &#125; catch (Exception e) &#123; log.error(&quot;onError.Exception&#123;&#125;&quot;, e.getMessage(), e); &#125; &#125; /** * 指定发送消息 */ public void sendMessage(String message, Session session) &#123; log.info(&quot;服务端给客户端[&#123;&#125;]发送消息&#123;&#125;&quot;, this.erp, message); try &#123; session.getBasicRemote().sendText(message); &#125; catch (IOException e) &#123; log.error(&quot;&#123;&#125;发送消息发生异常，异常原因&#123;&#125;&quot;, this.erp, message); &#125; &#125; /** * 群发消息 */ public void sendMessage(String message) &#123; for (Map.Entry&lt;String, ChickenSocket&gt; sessionEntry : clients.entrySet()) &#123; String erp = sessionEntry.getKey(); ChickenSocket socket = sessionEntry.getValue(); Session session = socket.session; log.info(&quot;服务端给客户端[&#123;&#125;]发送消息&#123;&#125;&quot;, erp, message); try &#123; session.getBasicRemote().sendText(message); &#125; catch (IOException e) &#123; log.error(&quot;&#123;&#125;发送消息发生异常，异常原因&#123;&#125;&quot;, this.erp, message); &#125; &#125; &#125;&#125; 集成Swagger模块swagger具有代码侵入性，小公司会使用 优化：通过配置文件的形式来对Swagger进行定制。 123456789101112131415161718192021222324252627282930@Configuration//swagger开关@EnableSwagger2public class SwaggerConfig &#123;//自动注入 @Autowired private SwaggerInfo swaggerInfo; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(swaggerInfo.getBasePackage())) .paths(PathSelectors.any()) .build(); &#125; public ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(swaggerInfo.getTitle()) .contact(new Contact(swaggerInfo.getContactName(), swaggerInfo.getContactUrl(), swaggerInfo.getEmail())) .version(swaggerInfo.getVersion()) .description(swaggerInfo.getDescription()) .build(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.jingdianjichi.swagger.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component//通过配置的方式填充属性@ConfigurationProperties(prefix = &quot;swagger&quot;)public class SwaggerInfo &#123; private String basePackage; private String title; private String contactName; private String contactUrl; private String email; private String version; private String description; public String getContactUrl() &#123; return contactUrl; &#125; public void setContactUrl(String contactUrl) &#123; this.contactUrl = contactUrl; &#125; public String getBasePackage() &#123; return basePackage; &#125; public void setBasePackage(String basePackage) &#123; this.basePackage = basePackage; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContactName() &#123; return contactName; &#125; public void setContactName(String contactName) &#123; this.contactName = contactName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getVersion() &#123; return version; &#125; public void setVersion(String version) &#123; this.version = version; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125;&#125; 集成Redis新增配置： 12345678910111213spring: redis: host: 117.78.51.210 port: 6379 database: 0#配置连接池 lettuce: pool: max-active: 20 max-idle: 8 max-wait: -1 min-idle: 0 password: jingdianjichi 配置redis序列化器以及RedisTemplate 12345678910111213141516171819202122232425262728@Configurationpublic class RedisConfig &#123; //RedisTemplate @Bean public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; RedisTemplate&lt;String,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); redisTemplate.setConnectionFactory(redisConnectionFactory); redisTemplate.setKeySerializer(redisSerializer); redisTemplate.setHashKeySerializer(redisSerializer); redisTemplate.setValueSerializer(jackson2JsonRedisSerializer()); redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer()); return redisTemplate; &#125; //设置序列化器 private Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer()&#123; Jackson2JsonRedisSerializer&lt;Object&gt; jsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false); objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); jsonRedisSerializer.setObjectMapper(objectMapper); return jsonRedisSerializer; &#125;&#125; 封装分布式锁 参数校验可以使用common-logging包的StringUtils进行参数判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.jingdianjichi.redis.util;import com.jingdianjichi.redis.exception.ShareLockException;import org.apache.commons.lang.StringUtils;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.util.concurrent.TimeUnit;/** * @Author: ChickenWing * @Description: Redis分布式锁 * @DateTime: 2022/9/24 22:28 */@Componentpublic class RedisShareLockUtil &#123; @Resource private RedisUtil redisUtil; private Long TIME_OUT = 1000L; /** * @Author: ChickenWing * @Description: 加锁 * @DateTime: 2022/9/24 21:25 */ //参数:localKey表示分布式锁的key，requestId作为value作为识别当前锁是不是之前添加的 public boolean lock(String lockKey, String requestId, Long time) &#123; //参数校验 if (StringUtils.isBlank(lockKey) || StringUtils.isBlank(requestId) || time &lt;= 0) &#123; throw new ShareLockException(&quot;分布式锁-加锁参数异常&quot;); &#125; long currentTime = System.currentTimeMillis(); long outTime = currentTime + TIME_OUT; Boolean result = false; //加锁自旋 while (currentTime &lt; outTime) &#123; //借助redis的setnx进行实现分布式锁 result = redisUtil.setNx(lockKey, requestId, time, TimeUnit.MILLISECONDS); if (result) &#123; return result; &#125; //休息后继续自旋 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; currentTime = System.currentTimeMillis(); &#125; return result; &#125; /** * @Author: ChickenWing * @Description:解锁 * @DateTime: 2022/9/24 21:25 */ public boolean unLock(String key, String requestId) &#123; if (StringUtils.isBlank(key) || StringUtils.isBlank(requestId)) &#123; throw new ShareLockException(&quot;分布式锁-解锁-参数异常&quot;); &#125; try &#123; //解锁关键：判断value是否和之前的requestID一致，不一致不能解锁 String value = redisUtil.get(key); if (requestId.equals(value)) &#123; redisUtil.del(key); return true; &#125; &#125; catch (Exception e) &#123; //补日志 &#125; return false; &#125; /** * @Author: ChickenWing * @Description: 尝试加锁 * @DateTime: 2022/9/24 21:26 */ public boolean tryLock(String lockKey, String requestId, Long time) &#123; if (StringUtils.isBlank(lockKey) || StringUtils.isBlank(requestId) || time &lt;= 0) &#123; throw new ShareLockException(&quot;分布式锁-尝试加锁参数异常&quot;); &#125; //尝试一次，不可以就返回false return redisUtil.setNx(lockKey, requestId, time, TimeUnit.MILLISECONDS); &#125;&#125; 场景 1.任务调度 2.计算金额 操作同一个数据 注解缓存123456789@Beanpublic RedisCacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory)&#123; RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory); RedisSerializationContext.SerializationPair&lt;Object&gt; pair = RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer()); RedisCacheConfiguration defaultCacheConfig = RedisCacheConfiguration.defaultCacheConfig() .serializeValuesWith(pair).entryTtl(Duration.ofSeconds(10)); return new RedisCacheManager(redisCacheWriter,defaultCacheConfig);&#125; @Cacheable注解缺点，所有的key都需要在Duration.ofSeconds(10)统一设置使用此注解的所有key的超时时间。这就导致所有的key的过期时间都相同 分布式锁业务场景1.任务调度 2.计算金额，线程安全 Guava本地缓存当redis在高并发情况下qps非常高的时候，会达到一定瓶颈，使用本地缓存作为二级缓存可以有效的redis的压力 CacheUtil本地缓存工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Component@Slf4jpublic class GuavaCacheUtil&lt;K, V&gt; &#123; @Resource public RedisUtil redisUtil; @Value(&quot;$&#123;guava.cache.switch&#125;&quot;) public Boolean switchCache; //初始化本地缓存 private Cache&lt;String, String&gt; localCache = CacheBuilder.newBuilder() .maximumSize(5000) .expireAfterWrite(3, TimeUnit.SECONDS) .build(); public Map&lt;K, V&gt; getResult(List&lt;K&gt; idList, String cacheKeyPrefix, String cacheSuffix, Class&lt;V&gt; clazz, Function&lt;List&lt;K&gt;, Map&lt;K, V&gt;&gt; function) &#123; if (CollectionUtils.isEmpty(idList)) &#123; return Collections.emptyMap(); &#125; Map&lt;K, V&gt; resultMap = new HashMap&lt;&gt;(16); if (!switchCache) &#123; resultMap = function.apply(idList); return resultMap; &#125; List&lt;K&gt; noCacheIdList = new LinkedList&lt;&gt;(); //遍历，没在本地缓存中的ID for (K id : idList) &#123; String cacheKey = cacheKeyPrefix + &quot;_&quot; + id + &quot;_&quot; + cacheSuffix; String content = localCache.getIfPresent(cacheKey); if (StringUtils.isNotBlank(content)) &#123; V v = JSON.parseObject(content, clazz); resultMap.put(id, v); &#125; else &#123; noCacheIdList.add(id); &#125; &#125; if (CollectionUtils.isEmpty(noCacheIdList)) &#123; return resultMap; &#125; //执行rpc方法 Map&lt;K, V&gt; noCacheResultMap = function.apply(noCacheIdList); if (noCacheResultMap == null || noCacheResultMap.isEmpty()) &#123; return resultMap; &#125; //生成结果集，并加到本地缓存中。 for (Map.Entry&lt;K, V&gt; entry : noCacheResultMap.entrySet()) &#123; K id = entry.getKey(); V result = entry.getValue(); resultMap.put(id, result); String cacheKey = cacheKeyPrefix + &quot;_&quot; + id + &quot;_&quot; + cacheSuffix; localCache.put(cacheKey, JSON.toJSONString(result)); &#125; return resultMap; &#125;&#125; Redis实现延迟队列功能：定时群发任务 定义群发任务 12345678@Datapublic class MassMailTask &#123; private Long taskId; private Date startTime;&#125; 延时发送 1234567891011121314151617181920212223242526272829303132333435363738** * @Author: ChickenWing * @Description: 群发任务延时service * @DateTime: 2023/1/8 23:24 */@Service@Slf4jpublic class MassMailTaskService &#123; @Resource private RedisUtil redisUtil; private static final String MASS_MAIL_TASK_KEY = &quot;massMailTask&quot;; public void pushMassMailTaskQueue(MassMailTask massMailTask) &#123; Date startTime = massMailTask.getStartTime(); if (startTime == null) &#123; return; &#125; if (startTime.compareTo(new Date()) &lt;= 0) &#123; return; &#125; log.info(&quot;定时群发任务加入延时队列，massMailTask:&#123;&#125;&quot;, JSON.toJSON(massMailTask)); redisUtil.zAdd(MASS_MAIL_TASK_KEY, massMailTask.getTaskId().toString(), startTime.getTime()); &#125; public Set&lt;Long&gt; poolMassMailTaskQueue() &#123; Set&lt;String&gt; taskIdSet = redisUtil.rangeByScore(MASS_MAIL_TASK_KEY, 0, System.currentTimeMillis()); log.info(&quot;获取延迟群发任务，taskIdSet：&#123;&#125;&quot;, JSON.toJSON(taskIdSet)); if (CollectionUtils.isEmpty(taskIdSet)) &#123; return Collections.emptySet(); &#125; redisUtil.removeZsetList(MASS_MAIL_TASK_KEY, taskIdSet); return taskIdSet.stream().map(n -&gt; Long.parseLong(n)).collect(Collectors.toSet()); &#125;&#125; 测试 12345678910111213141516171819202122232425262728293031@Testpublic void push() throws Exception &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); MassMailTask massMailTask = new MassMailTask(); massMailTask.setTaskId(1L); massMailTask.setStartTime(simpleDateFormat.parse(&quot;2023-01-08 23:59:00&quot;)); massMailTaskService.pushMassMailTaskQueue(massMailTask);&#125;@Testpublic void deal() throws Exception &#123; String lockKey = &quot;test.delay.task&quot;; String requestId = UUID.randomUUID().toString(); try &#123; boolean locked = redisShareLockUtil.lock(lockKey, requestId, 5L); if (!locked) &#123; return; &#125; Set&lt;Long&gt; taskIdSet = massMailTaskService.poolMassMailTaskQueue(); log.info(&quot;DelayTaskTest.deal.taskIdSet:&#123;&#125;&quot;, JSON.toJSON(taskIdSet)); if (CollectionUtils.isEmpty(taskIdSet)) &#123; return; &#125; //执行其他的业务逻辑 &#125; catch (Exception e) &#123; log.error(&quot;延时任务拉取执行失败&quot;, e); &#125; finally &#123; redisShareLockUtil.unLock(lockKey, requestId); &#125;&#125; 总结：实现效果：定时任务发布后，在时间没有到达之前拉取任务列表都无法拉取到，只有到达任务时间才能拉取到任务id Redis配合lua脚本实现caslua脚本:compareAndSet.lua 123456789101112local key = KEYS[1]local oldValue = ARGV[1]local newValue = ARGV[2]local redisValue = redis.call(&#x27;get&#x27;, key)if (redisValue == false or tonumber(redisValue) == tonumber(oldValue))then redis.call(&#x27;set&#x27;, key, newValue) return trueelse return falseend 初始化lua脚本 12345678910111213141516171819202122@Component@Slf4jpublic class RedisUtil &#123; //创建DefaultRedisScript脚本，并初始化 private DefaultRedisScript&lt;Boolean&gt; casScript; //使用init的时候，需要使用postContrstruct加载脚本 @PostConstruct public void init() &#123; casScript = new DefaultRedisScript&lt;&gt;(); casScript.setResultType(Boolean.class); casScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(&quot;compareAndSet.lua&quot;))); System.out.println(JSON.toJSON(casScript)); &#125; //cas方法 public Boolean compareAndSet(String key, Long oldValue, Long newValue) &#123; List&lt;String&gt; keys = new ArrayList(); keys.add(key); return (Boolean) redisTemplate.execute(casScript, keys, oldValue, newValue); &#125;&#125; 集成Log模块异步日志log4j指定日志文件路径 12logging:\tconfig:classpath:logging.xml resource目录下logging.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration status=&quot;INFO&quot; monitorInterval=&quot;5&quot;&gt; &lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt; &lt;!--变量配置--&gt; &lt;Properties&gt; &lt;!-- 格式化输出：%date表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %msg：日志消息，%n是换行符--&gt; &lt;!-- %logger&#123;36&#125; 表示 Logger 名字最长36个字符 --&gt; &lt;property name=&quot;LOG_PATTERN&quot; value=&quot;%date&#123;HH:mm:ss.SSS&#125; %X&#123;PFTID&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&quot; /&gt; &lt;!-- 定义日志存储的路径 --&gt; &lt;property name=&quot;FILE_PATH&quot; value=&quot;../log&quot; /&gt; &lt;property name=&quot;FILE_NAME&quot; value=&quot;frame.log&quot; /&gt; &lt;/Properties&gt; &lt;!--https://logging.apache.org/log4j/2.x/manual/appenders.html--&gt; &lt;appenders&gt; &lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout pattern=&quot;$&#123;LOG_PATTERN&#125;&quot;/&gt; &lt;!--控制台只输出level及其以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;/console&gt; &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt; &lt;File name=&quot;fileLog&quot; fileName=&quot;$&#123;FILE_PATH&#125;/temp.log&quot; append=&quot;false&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;LOG_PATTERN&#125;&quot;/&gt; &lt;/File&gt; &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt; &lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;$&#123;FILE_PATH&#125;/info.log&quot; filePattern=&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-INFO-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;&gt; &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;$&#123;LOG_PATTERN&#125;&quot;/&gt; &lt;Policies&gt; &lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;10MB&quot;/&gt; &lt;/Policies&gt; &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt; &lt;DefaultRolloverStrategy max=&quot;15&quot;/&gt; &lt;/RollingFile&gt; &lt;!-- 这个会打印出所有的warn及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt; &lt;RollingFile name=&quot;RollingFileWarn&quot; fileName=&quot;$&#123;FILE_PATH&#125;/warn.log&quot; filePattern=&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-WARN-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;&gt; &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;$&#123;LOG_PATTERN&#125;&quot;/&gt; &lt;Policies&gt; &lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;10MB&quot;/&gt; &lt;/Policies&gt; &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt; &lt;DefaultRolloverStrategy max=&quot;15&quot;/&gt; &lt;/RollingFile&gt; &lt;!-- 这个会打印出所有的error及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt; &lt;RollingFile name=&quot;RollingFileError&quot; fileName=&quot;$&#123;FILE_PATH&#125;/error.log&quot; filePattern=&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-ERROR-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;&gt; &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;$&#123;LOG_PATTERN&#125;&quot;/&gt; &lt;Policies&gt; &lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;10MB&quot;/&gt; &lt;/Policies&gt; &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt; &lt;DefaultRolloverStrategy max=&quot;15&quot;/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;!--Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。--&gt; &lt;!--然后定义loggers，只有定义了logger并引入的appender，appender才会生效--&gt; &lt;loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;&lt;!-- &lt;logger name=&quot;org.mybatis&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;--&gt;&lt;!-- &lt;AppenderRef ref=&quot;Console&quot;/&gt;--&gt;&lt;!-- &lt;/logger&gt;--&gt; &lt;!--监控系统信息--&gt; &lt;!--若是additivity设为false，则子Logger只会在自己的appender里输出，而不会在父Logger的appender里输出。--&gt;&lt;!-- &lt;Logger name=&quot;org.springframework&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;--&gt;&lt;!-- &lt;AppenderRef ref=&quot;Console&quot;/&gt;--&gt;&lt;!-- &lt;/Logger&gt;--&gt;&lt;!-- &lt;AsyncLogger name=&quot;asyncLog&quot; level=&quot;info&quot; additivity=&quot;true&quot;&gt;--&gt;&lt;!-- &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt;--&gt;&lt;!-- &lt;/AsyncLogger&gt;--&gt;&lt;!-- &lt;AsyncRoot level=&quot;info&quot; includeLocation=&quot;true&quot;&gt;--&gt;&lt;!-- &lt;AppenderRef ref=&quot;RollingFileInfo&quot; /&gt;--&gt;&lt;!-- &lt;/AsyncRoot&gt;--&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt; &lt;appender-ref ref=&quot;RollingFileWarn&quot;/&gt; &lt;appender-ref ref=&quot;RollingFileError&quot;/&gt; &lt;appender-ref ref=&quot;fileLog&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 引入异步日志 12345&lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;$&#123;disruptor.version&#125;&lt;/version&gt; &lt;/dependency&gt; 修改xml文件 123456789101112131415161718&lt;!-- 过滤掉spring和mybatis的一些无用的DEBUG信息 --&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;!-- 监控系统信息--&gt; &lt;!-- 若是additivity设为false，则子Logger只会在自己的appender里输出，而不会在父Logger的appender里输出。--&gt; &lt;Logger name=&quot;org.springframework&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;/Logger&gt; &lt;AsyncLogger name=&quot;asyncLog&quot; level=&quot;info&quot; additivity=&quot;true&quot;&gt; &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt; &lt;/AsyncLogger&gt; &lt;AsyncRoot level=&quot;info&quot; includeLocation=&quot;true&quot;&gt; &lt;AppenderRef ref=&quot;RollingFileInfo&quot; /&gt; &lt;/AsyncRoot&gt;&lt;!--注解掉root--&gt; 修改启动类 1234public static void main(String[] args) &#123; System.setProperty(&quot;Log4jContextSelector&quot;, &quot;org.apache.logging.log4j.core.async.AsyncLoggerContextSelector&quot;); SpringApplication.run(DemoApplication.class); &#125; 异步日志结果：2456- &gt;89 使用Gson和AOP打印入参出参配合traceId可以实现全链路打印 12345678910111213141516171819202122232425262728293031323334@Aspect@Slf4j@Component/**配置开关**/@ConditionalOnProperty(name = &#123;&quot;log.aspect.enable&quot;&#125;, havingValue = &quot;true&quot;, matchIfMissing = true)public class LogAspect &#123; @Pointcut(&quot;execution(* com.jingdianjichi.*.controller.*Controller.*(..)) || execution(* com.jingdianjichi.*.service.*Service.*(..))&quot;) private void pointCut() &#123; &#125; @Around(&quot;pointCut()&quot;) public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; Object[] reqArgs = pjp.getArgs(); String req = new Gson().toJson(reqArgs); //获取方法相关的信息 MethodSignature methodSignature = (MethodSignature) pjp.getSignature(); //获取方法名 String methodName = methodSignature.getDeclaringType().getName() + &quot;.&quot; + methodSignature.getName(); log.info(&quot;&#123;&#125;,req:&#123;&#125;&quot;, methodName, req); Long startTime = System.currentTimeMillis(); //执行方法，接收返回参数 Object responseObj = pjp.proceed(); String resp = new Gson().toJson(responseObj); Long endTime = System.currentTimeMillis(); log.info(&quot;&#123;&#125;,response:&#123;&#125;,costTime:&#123;&#125;&quot;, methodName, resp, endTime - startTime); return responseObj; &#125;&#125; 集成tools模块服务预热服务预热，当服务全部启动后，会优先启动这些服务。 1234567891011121314151617181920212223242526272829303132333435363738@Component@Slf4jpublic class ApplicationInit implements ApplicationListener&lt;ApplicationReadyEvent&gt; &#123; Map&lt;String, InitFunction&gt; initFunctionMap = new HashMap&lt;&gt;();//最先通过代码块，将需要预热的服务放到map中 &#123; initFunctionMap.put(&quot;预热fastjson&quot;, this::initFastJson); &#125;//监听事件，通过遍历map进行执行function函数。 @Override public void onApplicationEvent(ApplicationReadyEvent applicationReadyEvent) &#123; initFunctionMap.forEach((desc, function) -&gt; &#123; try &#123; long start = System.currentTimeMillis(); function.invoke(); log.info(&quot;ApplicationInit&#123;&#125;.costTime&#123;&#125;&quot;, desc, System.currentTimeMillis() - start); &#125; catch (Exception e) &#123; log.error(&quot;ApplicationInit&#123;&#125;.error&quot;, desc, e); &#125; &#125;); &#125;//预热服务的函数 private void initFastJson() &#123; SkuDO skuDO = new SkuDO(); skuDO.setSkuId(1L); skuDO.setSkuName(&quot;苹果&quot;); String s = JSON.toJSONString(skuDO); System.out.println(s); JSON.parseObject(s, SkuDO.class); &#125;//函数接口 interface InitFunction &#123; void invoke(); &#125;&#125; fastJson预热所需要的时间是243ms，如果在高峰流量过来的时候，可以为你节省243ms的时间，是不是非常划算 时间转化器123456789101112131415161718192021222324252627282930313233343536@Configuration@ConditionalOnClass(ObjectMapper.class)@AutoConfigureBefore(JacksonAutoConfiguration.class)public class JacksonConfig &#123; @Bean public Jackson2ObjectMapperBuilderCustomizer customizer() &#123; return jacksonObjectMapperBuilder -&gt; &#123; jacksonObjectMapperBuilder.locale(Locale.CHINA); jacksonObjectMapperBuilder.timeZone(TimeZone.getTimeZone(ZoneId.systemDefault())); jacksonObjectMapperBuilder.simpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); jacksonObjectMapperBuilder.modules(new JavaTimeModule()); &#125;; &#125; public static class JavaTimeModule extends SimpleModule &#123; public JavaTimeModule() &#123; this.addSerializer(LocalDateTime.class , new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;))); this.addSerializer(LocalDate.class , new LocalDateSerializer(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;))); this.addSerializer(LocalTime.class , new LocalTimeSerializer(DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;))); this.addDeserializer(LocalDateTime.class , new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))); this.addDeserializer(LocalDate.class , new LocalDateDeserializer(DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;))); this.addDeserializer(LocalTime.class , new LocalTimeDeserializer(DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;))); &#125; &#125;&#125; 集成xxl-job导入xxl-job模块，通过源码拉取配置文件 填写配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.xxl.job.executor.core.config;import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * xxl-job config * * @author xuxueli 2017-04-28 */@Configurationpublic class XxlJobConfig &#123; private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;) private String adminAddresses; @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;) private String accessToken; @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;) private String appname; @Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;) private String address; @Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;) private String ip; @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;) private int port; @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;) private String logPath; @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;) private int logRetentionDays; @Bean public XxlJobSpringExecutor xxlJobExecutor() &#123; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setAddress(address); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; &#125; /** * 针对多网卡、容器内部署等情况，可借助 &quot;spring-cloud-commons&quot; 提供的 &quot;InetUtils&quot; 组件灵活定制注册IP； * * 1、引入依赖： * &lt;dependency&gt; * &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; * &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt; * &lt;version&gt;$&#123;version&#125;&lt;/version&gt; * &lt;/dependency&gt; * * 2、配置文件，或者容器启动变量 * spring.cloud.inetutils.preferred-networks: &#x27;xxx.xxx.xxx.&#x27; * * 3、获取IP * String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress(); */&#125; 集成样例Handler 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254package com.xxl.job.executor.service.jobhandler;import com.xxl.job.core.context.XxlJobHelper;import com.xxl.job.core.handler.annotation.XxlJob;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.io.BufferedInputStream;import java.io.BufferedReader;import java.io.DataOutputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import java.util.Arrays;import java.util.concurrent.TimeUnit;/** * XxlJob开发示例（Bean模式） * * 开发步骤： * 1、任务开发：在Spring Bean实例中，开发Job方法； * 2、注解配置：为Job方法添加注解 &quot;@XxlJob(value=&quot;自定义jobhandler名称&quot;, init = &quot;JobHandler初始化方法&quot;, destroy = &quot;JobHandler销毁方法&quot;)&quot;，注解value值对应的是调度中心新建任务的JobHandler属性的值。 * 3、执行日志：需要通过 &quot;XxlJobHelper.log&quot; 打印执行日志； * 4、任务结果：默认任务结果为 &quot;成功&quot; 状态，不需要主动设置；如有诉求，比如设置任务结果为失败，可以通过 &quot;XxlJobHelper.handleFail/handleSuccess&quot; 自主设置任务结果； * * @author xuxueli 2019-12-11 21:52:51 */@Componentpublic class SampleXxlJob &#123; private static Logger logger = LoggerFactory.getLogger(SampleXxlJob.class); /** * 1、简单任务示例（Bean模式） */ @XxlJob(&quot;demoJobHandler&quot;) public void demoJobHandler() throws Exception &#123; XxlJobHelper.log(&quot;XXL-JOB, Hello World.&quot;); for (int i = 0; i &lt; 5; i++) &#123; XxlJobHelper.log(&quot;beat at:&quot; + i); TimeUnit.SECONDS.sleep(2); &#125; // default success &#125; /** * 2、分片广播任务 */ @XxlJob(&quot;shardingJobHandler&quot;) public void shardingJobHandler() throws Exception &#123; // 分片参数 int shardIndex = XxlJobHelper.getShardIndex(); int shardTotal = XxlJobHelper.getShardTotal(); XxlJobHelper.log(&quot;分片参数：当前分片序号 = &#123;&#125;, 总分片数 = &#123;&#125;&quot;, shardIndex, shardTotal); // 业务逻辑 for (int i = 0; i &lt; shardTotal; i++) &#123; if (i == shardIndex) &#123; XxlJobHelper.log(&quot;第 &#123;&#125; 片, 命中分片开始处理&quot;, i); &#125; else &#123; XxlJobHelper.log(&quot;第 &#123;&#125; 片, 忽略&quot;, i); &#125; &#125; &#125; /** * 3、命令行任务 */ @XxlJob(&quot;commandJobHandler&quot;) public void commandJobHandler() throws Exception &#123; String command = XxlJobHelper.getJobParam(); int exitValue = -1; BufferedReader bufferedReader = null; try &#123; // command process ProcessBuilder processBuilder = new ProcessBuilder(); processBuilder.command(command); processBuilder.redirectErrorStream(true); Process process = processBuilder.start(); //Process process = Runtime.getRuntime().exec(command); BufferedInputStream bufferedInputStream = new BufferedInputStream(process.getInputStream()); bufferedReader = new BufferedReader(new InputStreamReader(bufferedInputStream)); // command log String line; while ((line = bufferedReader.readLine()) != null) &#123; XxlJobHelper.log(line); &#125; // command exit process.waitFor(); exitValue = process.exitValue(); &#125; catch (Exception e) &#123; XxlJobHelper.log(e); &#125; finally &#123; if (bufferedReader != null) &#123; bufferedReader.close(); &#125; &#125; if (exitValue == 0) &#123; // default success &#125; else &#123; XxlJobHelper.handleFail(&quot;command exit value(&quot;+exitValue+&quot;) is failed&quot;); &#125; &#125; /** * 4、跨平台Http任务 * 参数示例： * &quot;url: http://www.baidu.com &quot; + * &quot;method: get &quot; + * &quot;data: content &quot;; */ @XxlJob(&quot;httpJobHandler&quot;) public void httpJobHandler() throws Exception &#123; // param parse String param = XxlJobHelper.getJobParam(); if (param==null || param.trim().length()==0) &#123; XxlJobHelper.log(&quot;param[&quot;+ param +&quot;] invalid.&quot;); XxlJobHelper.handleFail(); return; &#125; String[] httpParams = param.split(&quot; &quot;); String url = null; String method = null; String data = null; for (String httpParam: httpParams) &#123; if (httpParam.startsWith(&quot;url:&quot;)) &#123; url = httpParam.substring(httpParam.indexOf(&quot;url:&quot;) + 4).trim(); &#125; if (httpParam.startsWith(&quot;method:&quot;)) &#123; method = httpParam.substring(httpParam.indexOf(&quot;method:&quot;) + 7).trim().toUpperCase(); &#125; if (httpParam.startsWith(&quot;data:&quot;)) &#123; data = httpParam.substring(httpParam.indexOf(&quot;data:&quot;) + 5).trim(); &#125; &#125; // param valid if (url==null || url.trim().length()==0) &#123; XxlJobHelper.log(&quot;url[&quot;+ url +&quot;] invalid.&quot;); XxlJobHelper.handleFail(); return; &#125; if (method==null || !Arrays.asList(&quot;GET&quot;, &quot;POST&quot;).contains(method)) &#123; XxlJobHelper.log(&quot;method[&quot;+ method +&quot;] invalid.&quot;); XxlJobHelper.handleFail(); return; &#125; boolean isPostMethod = method.equals(&quot;POST&quot;); // request HttpURLConnection connection = null; BufferedReader bufferedReader = null; try &#123; // connection URL realUrl = new URL(url); connection = (HttpURLConnection) realUrl.openConnection(); // connection setting connection.setRequestMethod(method); connection.setDoOutput(isPostMethod); connection.setDoInput(true); connection.setUseCaches(false); connection.setReadTimeout(5 * 1000); connection.setConnectTimeout(3 * 1000); connection.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;); connection.setRequestProperty(&quot;Accept-Charset&quot;, &quot;application/json;charset=UTF-8&quot;); // do connection connection.connect(); // data if (isPostMethod &amp;&amp; data!=null &amp;&amp; data.trim().length()&gt;0) &#123; DataOutputStream dataOutputStream = new DataOutputStream(connection.getOutputStream()); dataOutputStream.write(data.getBytes(&quot;UTF-8&quot;)); dataOutputStream.flush(); dataOutputStream.close(); &#125; // valid StatusCode int statusCode = connection.getResponseCode(); if (statusCode != 200) &#123; throw new RuntimeException(&quot;Http Request StatusCode(&quot; + statusCode + &quot;) Invalid.&quot;); &#125; // result bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream(), &quot;UTF-8&quot;)); StringBuilder result = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) &#123; result.append(line); &#125; String responseMsg = result.toString(); XxlJobHelper.log(responseMsg); return; &#125; catch (Exception e) &#123; XxlJobHelper.log(e); XxlJobHelper.handleFail(); return; &#125; finally &#123; try &#123; if (bufferedReader != null) &#123; bufferedReader.close(); &#125; if (connection != null) &#123; connection.disconnect(); &#125; &#125; catch (Exception e2) &#123; XxlJobHelper.log(e2); &#125; &#125; &#125; /** * 5、生命周期任务示例：任务初始化与销毁时，支持自定义相关逻辑； */ @XxlJob(value = &quot;demoJobHandler2&quot;, init = &quot;init&quot;, destroy = &quot;destroy&quot;) public void demoJobHandler2() throws Exception &#123; XxlJobHelper.log(&quot;XXL-JOB, Hello World.&quot;); &#125; public void init()&#123; logger.info(&quot;init&quot;); &#125; public void destroy()&#123; logger.info(&quot;destroy&quot;); &#125;&#125; SpringMVC静态页面访问123spring:\tmvc: static-path-pattern:/static/** Event事件驱动使用观察者默认，以及事件驱动的思想去监听 12345@Datapublic class Person&#123; private Integer age; private String name;&#125; 创建事件 1234567891011121314@Data@Getterpublic class PersonChangeEvent implement ApplicationEvent&#123; private Person person; private String operateType; PersonChangeEvent(Person preson , String operateType )&#123; super(person); this.person = person; this.operateType = operateType; &#125;&#125; 事件创建完成，如何发布？？ 123456789101112@Service@Slf4jpublic class PersonEventService&#123; @Resource private ApplicationEventPublisher applicationEventPublisher; public void createEvent(Person person)&#123; applicationEventPublisher.pushlishEvent(PersonChangeEvent(person,&quot;create&quot;)); &#125; &#125; 事件监听（观察者） 1234567891011121314151617@Service@Slf4jpublic class PersonEventListener &#123; //全局事务处理器 @TransactionalEventListener(fallbackExecution = true) public void listenSecKillCreateEvent(PersonChangeEvent event) &#123; switch (event.getOperateType()) &#123; case &quot;create&quot;: log.info(&quot;执行创建相关事件,person：&#123;&#125;&quot;, JSON.toJSONString(event.getPerson())); break; default: break; &#125; &#125;&#125; 测试 1234567@Testpublic void test() &#123; Person person = new Person(); person.setName(&quot;经典鸡翅&quot;); person.setAge(18); personEventService.creatPerson(person);&#125; 总结：实现解耦，类似mq，如果需要类似功能且没必要去增加一个中间件的负担，可以使用事件驱动方式去实现推送监听的方式 手写 链路追踪梳理原来的日志打印逻辑： 123 &lt;property name=&quot;LOG_PATTERN&quot; value=&quot;%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&quot; /&gt;&lt;!--打印时间，，线程，信息--&gt; 所有日志全部混在一起，没有区分度所以引入%X{PFTID}profiletrilId 进行链路追踪 1234567/**traceId 常量*/public class TraceIdConstant &#123; public static final String TRACE_ID = &quot;PFTID&quot;;&#125; 设置traceId上下文 12345678910111213141516171819202122public class TraceIdContext &#123;//ThreadLocal无法在线程中传递可以使用InheritableThreadLocal public static final ThreadLocal&lt;String&gt; CURRENT_TRACE_ID = new InheritableThreadLocal&lt;&gt;(); public static String generateTraceId() &#123; return UUID.randomUUID().toString(); &#125; public static String getTraceId() &#123; return MDC.get(TraceIdConstant.TRACE_ID); &#125; public static void setTraceId(String traceId) &#123; MDC.put(TraceIdConstant.TRACE_ID, traceId); &#125; public static void clearTraceId() &#123; CURRENT_TRACE_ID.set(null); CURRENT_TRACE_ID.remove(); &#125;&#125; 构建traceFilter追踪过滤器 123456789101112131415161718@Component@Slf4jpublic class TraceIdFilter implements Filter &#123; @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) req; String traceId = request.getHeader(TraceIdConstant.TRACE_ID); if (StringUtils.isBlank(traceId)) &#123; traceId = TraceIdContext.generateTraceId(); &#125; TraceIdContext.setTraceId(traceId); filterChain.doFilter(request, resp); TraceIdContext.clearTraceId(); &#125;&#125; 书写配置类，设置自定义过滤器 1234567891011121314151617@Configurationpublic class FilterConfig &#123; @Resource private TraceIdFilter traceIdFilter; @Bean public FilterRegistrationBean registerTraceFilter() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(traceIdFilter); registration.addUrlPatterns(&quot;/*&quot;); registration.setName(&quot;traceIdFilter&quot;); registration.setOrder(1); return registration; &#125;&#125; 动态配置读取动态更改配置文件，无需重启立刻生效 123456789101112131415161718public class PropertiesUtils&#123; Map&lt;String, Properties&gt; propertiesMap = new HashMap&lt;&gt;(); Map&lt;String, Long&gt; modifyTimeMap = new HashMap&lt;&gt;();\tprivate String configPath = &quot;&quot;; private PropertiesUtils()&#123;&#125; public void setConfigPath(String configPath)&#123; this.configPath = configPath; &#125; public static class SinglerHolder&#123; private static PropertiesUtils instance = new PropertiesUtils(); &#125; public static PropertiesUtils getInstance()&#123; return instance; &#125;&#125; 枚举优化正常根据code获取value是进行for循环进行取获取，可以转换成map方式取get达到空间换时间的目的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @Author: ChickenWing * @Description: 渠道枚举 * @DateTime: 2022/11/19 20:36 */@Getterpublic enum ChannelEnum &#123; DOU_YIN(0, &quot;抖音渠道&quot;), BILIBILI(1, &quot;B站渠道&quot;); private int code; private String desc; ChannelEnum(int code, String desc) &#123; this.code = code; this.desc = desc; &#125; public static final Map&lt;Integer, ChannelEnum&gt; clientChannelMap = Stream.of(ChannelEnum.values()) .collect(Collectors.toMap(e -&gt; e.getCode(), e -&gt; e)); public static Integer getCode(String channel) &#123; if (StringUtils.isBlank(channel)) &#123; return null; &#125; ChannelEnum clientChannel = clientChannelMap.get(channel); if (null == clientChannel) &#123; return null; &#125; return clientChannel.getCode(); &#125; /** * 根据code值获取渠道枚举 */ public static ChannelEnum getByCode(int codeVal) &#123; for (ChannelEnum channelEnum : ChannelEnum.values()) &#123; if (channelEnum.code == codeVal) &#123; return channelEnum; &#125; &#125; return null; &#125; /** * 根据code值获取desc */ public static String getValueByCode(int code) &#123; ChannelEnum[] values = ChannelEnum.values(); for (ChannelEnum channelEnum : values) &#123; if (channelEnum.code == code) &#123; return channelEnum.desc; &#125; &#125; return null; &#125;&#125; 多线程自定义线程池场景：由于业务线的线程池很多，每次都需要一个threadpool。所以需要对特定的线程池定制化 12345678910 @Configurationpublic class ThreadPollConfig&#123; @Bean(name=&quot;mailThreadPool&quot;) public ThreadExectorPool getMailThreadPool()&#123; //如果不传入线程工厂，底层就会使用默认的线程工厂 return new ThreadExectorPool(20, 50, 10, TimeUnit.SECONDS, new LinkedBlockLingQueue&lt;&gt;(), new ThreadPoolExecutor.CallerRunsPolicy()) &#125;&#125; 测试使用自定义线程 1234567891011121314@Resource(name= &quot;mailThreadPool&quot;)private ThreadExectorPool mailThreadPool;@Testvoid test()&#123; for (int i = 0; i &lt; 10; i++) &#123; mailThreadPool.submit(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;当前时间:&quot; + System.currentTimeMillis()); &#125; &#125;); &#125; &#125; 问题：打印日志无法辨识是哪一个线程池所产生的，没有辨识度。所以需要引入自定义线程工厂 自定义线程工厂123456789101112131415161718192021222324252627282930313233343536373839public class MailThreadFactory implement ThreadFactiory()&#123; //多线程环境保证变量的原子性，使用AtomicInteger private final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup threadGroup; private final AtomicInteger threadNumber = new AtomicInteger(1); public final String namePrefix; CustomNameThreadFactory(String name) &#123; SecurityManager s = System.getSecurityManager(); threadGroup = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); if (null == name || &quot;&quot;.equals(name.trim())) &#123; name = &quot;pool&quot;; &#125; //自定义逻辑，拼接线程name namePrefix = name + &quot;-&quot; + poolNumber.getAndIncrement() + &quot;-thread-&quot;; &#125; @Override public Thread newThread(Runnable r) &#123; Thread t = new Thread(threadGroup, r, namePrefix + threadNumber.getAndIncrement(), 0); //判断是否守护线程 if (t.isDaemon()) t.setDaemon(false); //优先级 if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125;&#125; 异步线程池封装目的： 异步执行task的时候，我可以进行异步执行，当执行结果阻塞可以返回默认值，且不形象其他的线程执行结果 123456789101112131415161718192021222324/** * 异步future工具类封装 * * @author: ChickenWing * @date: 2023/1/15 */public class CompletableFutureUtils &#123; /** * 获取future返回结果 */ public static &lt;T&gt; T getResult(Future&lt;T&gt; future, long timeout, TimeUnit timeUnit, T defaultValue, Logger logger) &#123; //超时返回默认结果 try &#123; return future.get(timeout, timeUnit); &#125; catch (Exception e) &#123; logger.error(&quot;CompletableFutureUtils.getResult.error:&#123;&#125;,defaultValue:&#123;&#125;&quot;, e.getMessage(), e); logger.error(&quot;CompletableFutureUtils.getResult.error.returnDefaultValue:&#123;&#125;&quot;, defaultValue); return defaultValue; &#125; &#125;&#125; 测试类： 12345678910111213141516171819202122@Test public void testFuture() &#123; List&lt;FutureTask&lt;String&gt;&gt; futureTaskList = new LinkedList&lt;&gt;(); FutureTask futureTask1 = new FutureTask&lt;String&gt;(() -&gt; &#123; return &quot;鸡翅&quot;; &#125;); FutureTask futureTask2 = new FutureTask&lt;String&gt;(() -&gt; &#123; Thread.sleep(2000); return &quot;经典&quot;; &#125;); futureTaskList.add(futureTask1); futureTaskList.add(futureTask2); mailThreadPool.submit(futureTask1); mailThreadPool.submit(futureTask2); for (int i = 0; i &lt; futureTaskList.size(); i++) &#123; String name = CompletableFutureUtils.getResult(futureTaskList.get(i), 1, TimeUnit.SECONDS, &quot;经典鸡翅&quot;, log); log.info(&quot;MailThreadPoolTest.name:&#123;&#125;&quot;,name); &#125; &#125; 线程池两种关闭方式通过executer.shutdown（）方法进行关闭，isShutDown（）方法可以观看线程池是否关闭 123456789101112131415161718192021222324252627282930313233343536@SpringBootTest(classes = DemoApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)@RunWith(SpringRunner.class)@Slf4jpublic class ThreadPoolShutDownTest &#123; @Test public void testShutDown() throws Exception &#123; ExecutorService executorService = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 1000; i++) &#123; executorService.execute(new TaskShutDownPool()); &#125; Thread.sleep(1000); log.info(&quot;ThreadPoolShutDownTest.testShutDown.status:&#123;&#125;&quot;, executorService.isShutdown() + &quot;,调用 shutdown() 方法之前&quot;); executorService.shutdown(); log.info(&quot;ThreadPoolShutDownTest.testShutDown.status:&#123;&#125;&quot;, executorService.isShutdown() + &quot;,调用 shutdown() 方法之后&quot;); Thread.sleep(500); log.info(&quot;ThreadPoolShutDownTest.testShutDown&quot;); executorService.execute(new TaskShutDownPool()); &#125; class TaskShutDownPool implements Runnable &#123; @Override public void run() &#123; try &#123; Thread.sleep(500); log.info(Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; log.info(&quot;TaskShutDownPool.interrupted:&#123;&#125;&quot;, e.getMessage(), e); &#125; &#125; &#125;&#125; 运行结果： image-20230922142001991 结论：shutdown方法不会让线程池立刻关闭，而是将正在执行的任务和等待执行的任务全部执行完，然后在进行关闭 isShutdown和isTerminated方法的区别isShutdown()方法判断是否关闭，而isTerminated()方法判断线程池整体的任务完全执行结束 shutdown()和shutdownNow()方法的区别shutdown()方法终止线程池继续在添加新的任务，当所有等待的以及正在执行的任务完成后关闭线程池，而shutdownNow()方法是立刻关闭线程池，无论是否正在执行任务，都会抛出InterruptException异常 合理的关闭线程池封装关闭线程池的工具类 12345678910111213141516171819public class ThreadShutDownUtil&#123; private ThreadShutDownUtil(); public static void shutdownPool(ExecutorService pool, int shutDownTimeOut, int shutDownNowtimOut, TimeUnit timeunit)&#123; pool.shutdown(); try&#123; if(!pool.awitTermination(10L, timeUnit))&#123; pool.shutdownNow(); if(!pool.awitTermination(10L, timeUnit))&#123; log.error(&quot;ThreadPoolUtils.shutDownPool.error&quot;); &#125; &#125;catch(InterrupterException e)&#123; log.error(&quot;ThreadPoolUtils.shutDownPool.interrupt.error:&#123;&#125;&quot;, e.getMessage(), e); pool.shutdownNow(); Thread.currentThread().interrupt(); &#125; &#125; &#125;&#125;"}]